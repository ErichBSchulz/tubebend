<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracheal Intubation Geometry Simulation</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f8f9fa;
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        h1, h2 {
            color: #007bff;
        }
        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
        }
        .left-column, .right-column {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin: 10px;
        }
        .slider-container {
            margin: 20px 0;
        }
        .slider-container label {
            width: 200px;
            text-align: right;
            margin-right: 10px;
        }
        .slider-container input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .slider-container span {
            width: 50px;
            text-align: left;
        }
        .description {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
        }
        .notes {
            padding: 20px;
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin: 20px;
        }
        .slider-container input[type="range"]:hover {
            cursor: pointer;
        }
    </style>
  
</head>
<body>
    <h1>Tracheal Intubation Geometry Simulation in 2D</h1>

    <div class="main-container">
        <div class="left-column">
            <div class="canvas-wrapper">
                <canvas id="canvas" width="1500" height="1500"></canvas>
            </div>
        </div>
        <div class="right-column">
            <h2>Parameters</h2>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="tubeAngle">Tube Angle (degrees): </label>
                    <input type="range" id="tubeAngle" min="170" max="250" value="206">
                    <span id="tubeAngleValue">0</span>
                </div>
                <p class="description">This is the angle the tube leaves the upper incisors.</p>
            </div>
        <!--
            <div class="slider-container">
                <div class="slider-row">
                    <label for="incisorBend">Incisor Bend (degrees): </label>
                    <input type="range" id="incisorBend" min="0" max="180" value="20">
                    <span id="incisorBendValue">0</span>
                </div>
                <p class="description">Bending is a result of the tube being bent over the upper incisors.</p>
            </div>
        -->
            <div class="slider-container">
                <div class="slider-row">
                    <label for="glotticPlaneX">Glottic Plane X (mm):</label>
                    <input type="range" id="glotticPlaneX" min="90" max="300" value="165">
                    <span id="glotticPlaneXValue">0</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="tubeLength">Tube Length (mm): </label>
                    <input type="range" id="tubeLength" min="90" max="300" value="280">
                    <span id="tubeLengthValue">0</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="tubeRadius">Tube Radius (mm): </label>
                    <input type="range" id="tubeRadius" min="50" max="500" value="150">
                    <span id="tubeRadiusValue">0</span>
                </div>
                <p class="description">The radius of curvature of standard tracheal tube is 140mm when it leaves the packet, but bending over the teeth will increase this.</p>
            </div>
            <h2>Laryngoscope Blade</h2>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="bladeLength">Blade Length (mm): </label>
                    <input type="range" id="bladeLength" min="40" max="150" value="140">
                    <span id="bladeLengthValue">0</span>
                </div>
                <p class="description">Macintosh blade #3 and #4 are 101mm and 135mm long respectively.</p>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="bladeInsertion">Blade Insertion (%): </label>
                    <input type="range" id="bladeInsertion" min="50" max="100" value="72">
                    <span id="bladeInsertionValue">0</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="bladeRadius">Blade Curvature Radius (mm): </label>
                    <input type="range" id="bladeRadius" min="70" max="140" value="118">
                    <span id="bladeRadiusValue">0</span>
                </div>
                <p class="description">Macintosh blade #3 and #4 have radii of 118mm and 136mm respectively.</p>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="bladeAngle">Blade angle (degrees): </label>
                    <input type="range" id="bladeAngle" min="-20" max="70" value="18">
                    <span id="bladeAngleValue">0</span>
                </div>
                <p class="description">This is the angle at the incisors.</p>
            </div>
            <h2>Dentition</h2>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="lowerIncisorX">Lower Incisor X (mm): </label>
                    <input type="range" id="lowerIncisorX" min="-100" max="10" value="-25">
                    <span id="lowerIncisorXValue">0</span>
                </div>
                <p class="description">Mouth opening as measured horizontally.</p>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="lowerIncisorY">Lower Incisor Y (mm): </label>
                    <input type="range" id="lowerIncisorY" min="-50" max="50" value="0">
                    <span id="lowerIncisorYValue">0</span>
                </div>
                <p class="description">Under or overbite.</p>
            </div>
            <h2>Reference params</h2>
            <p class="description">This moves a small pink fiducial.</p>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="startAngle">Start Angle (degrees): </label>
                    <input type="range" id="startAngle" min="0" max="360" value="0">
                    <span id="startAngleValue">0</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="endAngle">End Angle (degrees): </label>
                    <input type="range" id="endAngle" min="0" max="360" value="360">
                    <span id="endAngleValue">90</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="thickness">Thickness: </label>
                    <input type="range" id="thickness" min="1" max="20" value="1">
                    <span id="thicknessValue">5</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="x">X Coordinate: </label>
                    <input type="range" id="x" min="0" max="400" value="0">
                    <span id="xValue">250</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="y">Y Coordinate: </label>
                    <input type="range" id="y" min="0" max="400" value="0">
                    <span id="yValue">250</span>
                </div>
            </div>
            <div class="slider-container">
                <div class="slider-row">
                    <label for="showLabels">Show labels: </label>
                    <input type="checkbox" id="showLabels" checked>
                </div>
            </div>
        </div>
    </div>
    <div id="notes" class="notes">
        <h1>Notes:</h1>
      <h2>Why this page?</h2>
        <p>This page aims to help those seeking to learn or teach tracheal intubation understand some of the geometry.
        <p>It does this by illustrating the adverse impact of bending an endotracheal tube over the upper incisors while attempting tracheal intubation.</p>
      <h2>What do I do?</h2>
        <p>Slide the <em>Tube Angle</em> slider back and forth watching the impact on tube tip positions.
      </p>
      <h2>What am I looking at?</h2>
        <p>Above is a simplified diagram showing the upper and lower incisors (white triangles), the laryngoscope blade (grey arc) and a tracheal tube. A red bar is placed a the level of the blade tip to provide a approximate reference for the glottic opening between the vocal cords.</p>
      <h2>Why does the tip go backwards when the tube is rotated back?</h2>
        <p>Ah, this is the interesting point.
        As the tube is tilted back over the teeth the tube-blade contact point (shown with a red dot) migrates upwards. 
        Because of the curve of the blade the tube is deflected posteriorly in an unintuitive manner.</p>
      <h2>But if bending over the teeth is not the answer, what is?</h2>
      <p>As I showed in <a href="https://www.medrxiv.org/content/10.1101/2023.08.22.23294387v1">earlier work</a>,
      optimal tracheal tube orientation is to pull the tube laterally at the level of the mouth (to the right),
      so that you can rotate the tube backwards without bending it or shifting the blade-tube contact point.
        Avoid rolling the tube over. It's complicated.
        You may need to <a href="https://www.medrxiv.org/content/10.1101/2023.08.22.23294387v1">read the paper</a>.
      </p>
      <h2>What is tracheal intubation?</h2>
        <p>Tracheal intubation is a vital skill for paramedics and emergency doctors, but training opportunities are scarce.
            The challenges in gaining experience
            requires innovative training methods to maximimise the chances healthcare workers can intubate in emergency situations. 
        </p>
      <p>In an emergency successful intubation can save a life, prevent brain damage or prevent fatal aspiration of gastric acid into the lungs.</p>
      <h2>Notes</h2>
        <ul>
            <li>The model assumes that the deflection angle when the tube reflects off the teeth will be matched by the deflection angle over the teeth themselves.</li>
            <li>The model will break if you put in extreme values, eg a tube radius that is less than the blade radius.</li>
            <li>The glottic marker tracks the blade tip height but can be moved further or close to the blade tip with <em>Glottic Plane X</em> slider.</li>
            <li>If you would like to take measurements, you can do so simply with the little fiducial.</li>
        </ul>
    </div>


    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const sliders = [ 'tubeAngle', 
          // 'incisorBend', 
          'tubeRadius', 'glotticPlaneX', 'tubeLength',
          'bladeLength', 'bladeInsertion', 'bladeRadius', 'bladeAngle', 'lowerIncisorX', 'lowerIncisorY', 
          'startAngle', 'endAngle', 'thickness', 'x', 'y']
        // shortcut function
        const e = document.getElementById.bind(document);
        // shortcut to read value
        const ev = id => +e(id).value;
        // read degrees and convirt to radians
        const toRadians = degrees => (degrees * Math.PI) / 180;
        const toDegrees = radians => (radians / Math.PI) * 180;
        const evd = id => toRadians(ev(id));
        const scale = {f:5, xo: -100, yo: -100} 

        function init() {
          sliders.forEach(slider => e(slider).addEventListener('input', redraw));
          e('showLabels').addEventListener('change', redraw); 
          redraw()
        }

        function redraw() {
          updateValues();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const toothX= 300;
          const toothY= 200;
          const lowerIncisorX = toothX + ev('lowerIncisorX')
          const lowerIncisorY = toothY + ev('lowerIncisorY')
          // draw teeth
          drawTooth({x: toothX,y: toothY, height:10, lineWidth:1});
          drawTooth({x: lowerIncisorX, y: lowerIncisorY, height:-10, lineWidth:1});


          // draw blade
          const bladeLength = ev('bladeLength')
          const bladeInsertion = ev('bladeInsertion')
          const bladeRadius = ev('bladeRadius')
          const bit = bladeLength/(bladeRadius*2)
          // const bit = bladeRadius/(bladeLength/2)
          const bladeRadians = Math.asin(bit) * 2;
          const bladeAngle = evd('bladeAngle')
          const bladeCentre = translate({x: lowerIncisorX, y: lowerIncisorY, angle: bladeAngle + Math.PI, distance: bladeRadius});
          // drawDot({...bladeCentre, style: 'yellow'});
          const blade = { ...bladeCentre, 
            startAngle: bladeAngle-bladeRadians*(1- (bladeInsertion/100)),
            endAngle: bladeAngle + bladeRadians*((bladeInsertion/100)),
            radius: bladeRadius, 
            thickness: 3,
            style: "metal"}
          const bladeTip = translate({...bladeCentre, angle: blade.endAngle, distance: blade.radius })
          drawArc(blade);
          drawDot({...bladeTip, style: 'gray'});

          const tubeLength = ev('tubeLength')
          const tubeRadius = ev('tubeRadius')

          const tubeArcAngle = tubeLength / tubeRadius 
          // const circ = tubeRadius * 2 * Math.PI;
          // const fraction = tubeLength / circ; 
          const tubeRadians = tubeLength / tubeRadius;
          const tubeAngle = evd('tubeAngle');
          const tubeParams = {style: "tube", radius: tubeRadius, thickness: 10};

          const glotticPlaneX = ev('glotticPlaneX')
          drawGlottis({start: {x: glotticPlaneX, y: bladeTip.y-10}, end: {x: glotticPlaneX, y: bladeTip.y+10}, })

          const toothRotationCentre = {x: toothX-tubeParams.thickness/2, y: toothY-tubeParams.thickness/2}
          const inflection = translate({...toothRotationCentre, angle: tubeAngle, distance: tubeRadius})
          // drawDot(inflection)
        
          // draw second arc
          const angleToTooth2 = tubeAngle + Math.PI; 
          const arcParams2 = { ...inflection, startAngle: angleToTooth2, endAngle: angleToTooth2 + 1, ...tubeParams};
          var drawnTubeRadians = 0;
          var bend = 0;
          var tubeTip; // used for placing final angle
          // find the intersection of the tube and blade
          const intersection = findIntersection(arcParams2, 
            // modify blade to add thickness
            {...blade, radius: blade.radius + (blade.thickness+tubeParams.thickness)/2});
          if (intersection !== null && intersection.x > bladeTip.x && intersection.y > toothY) { 
              // collision!
              // calculate bearing from centre of blade curve to intersection point so can 
              // calucate the new rotation centre of a tangental tube
              const tubeBladeAxisBearing = calculateBearing(intersection, blade);
              // get the anglar location of the tube so we can derive the length of the section 3
              const tube2AxisBearing = calculateBearing(intersection, arcParams2);
              arcParams2.endAngle = tube2AxisBearing.angle - Math.PI;
              // todo draw the "ghost" tube
              const arc3Centre = translate({...intersection, angle: tubeBladeAxisBearing.angle,
              distance: tubeRadius});
              const arcParams3 = {...arc3Centre, ...tubeParams}
              const tangentBearing = tubeBladeAxisBearing.angle + Math.PI;
              arcParams3.startAngle = tangentBearing;
              bend = tangentAngle(intersection, arcParams3, arcParams2)
              // calculate angle to glotticPlaneX
              const deltaX = glotticPlaneX - arcParams3.x;
              //const finalAngle = Math.asin(deltaX/arcParams3.radius);
              const finalAngle = Math.acos(deltaX/arcParams3.radius);
              arcParams3.endAngle = finalAngle > arcParams3.startAngle ? finalAngle : arcParams3.startAngle;
              drawArc(arcParams3);
              drawnTubeRadians += arcRadians(arcParams3);
              drawDot({...intersection, style: 'red'});
              tubeTip = translate({...arc3Centre, angle: arcParams3.endAngle, distance: tubeRadius })
          }
          else {
            // no collision
            // arcParams2.style = "green"
            // calculate angle to glotticPlaneX
            const deltaX = glotticPlaneX - arcParams2.x;
            //const finalAngle = Math.asin(deltaX/arcParams2.radius);
            const finalAngle = Math.acos(deltaX/arcParams2.radius);
            arcParams2.endAngle = finalAngle;
            tubeTip = translate({...arcParams2, angle: finalAngle, distance: tubeRadius })
          }
          drawArc(arcParams2);
          // figure out how much tube has been drawn so far:
          drawnTubeRadians += arcRadians(arcParams2);
          const remainingRadians = tubeRadians - drawnTubeRadians;
          if (remainingRadians > 0) { // not all th tub is in th mouth. yay!
            // const incisorBend = bend; //evd('incisorBend');
            const angleToTooth1 = tubeAngle + bend//2 + Math.PI; 
            const outerCentre = translate({...toothRotationCentre, angle: tubeAngle + bend, distance: tubeRadius})
            // drawDot(outerCentre)
            const arcParams1 = { ...outerCentre, endAngle: angleToTooth1-Math.PI, ...tubeParams} 
            arcParams1.startAngle = arcParams1.endAngle - remainingRadians;
            drawArc(arcParams1);
          }

          // reference arc 
          const startAngle = evd("startAngle");
          const endAngle = evd("endAngle");
          const thickness = ev("thickness");
          const x = ev("x");
          const y = ev("y");
          const radius = 5;
          const style = "pink";
          const arcParams = { startAngle, endAngle, thickness, x, y, radius, style };
          drawArc(arcParams);

          // Draw labels if the checkbox is checked
          if (e('showLabels').checked) {
              label({ x: lowerIncisorX, y: lowerIncisorY, text: 'Lower Incisor', alignment: 'left' });
              label({ x: toothX, y: toothY, text: 'Upper Incisor', alignment: 'right' });
              label({ x: bladeTip.x, y: bladeTip.y, text: 'Blade', alignment: 'above' });
              label({ x: glotticPlaneX, y: bladeTip.y, text: 'Glottis', alignment: 'above' });
              label({ x: tubeTip.x, y: tubeTip.y, text: 'Tube', alignment: 'below' });
          }
        }

        // cartesian translation
        function arcRadians(arc) {
          var r = (arc.endAngle - arc.startAngle) % (2 * Math.PI);
          if (r<0) {
            r+=2 * Math.PI;
          }
          return r;
        }

        // cartesian translation
        function translate({x, y, angle, distance}) {
          return {x: x+Math.cos(angle)*distance, y: y+Math.sin(angle)*distance, }
        }

        // given two points calcuate angle and distance between them
        function calculateBearing(point1, point2) {
            const { x: x1, y: y1 } = point1;
            const { x: x2, y: y2 } = point2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            // calculate distance between points
            const distance = Math.sqrt(dx * dx + dy * dy);
            return {angle, distance};
        }

        // get the cordinates of the tip of an arc
        function arcTip(params) {
          return translate({...params, angle: params.endAngle})
        }

        // Calculate the intersection of two circles and 
        // returns the one with the highest Y value (and highest X value if there's a tie).
        function findIntersection(circle1, circle2) {
            const { x: x1, y: y1, radius: r1 } = circle1;
            const { x: x2, y: y2, radius: r2 } = circle2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d > r1 + r2 || d < Math.abs(r1 - r2)) {
                // No intersection
                return null;
            }
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(r1 * r1 - a * a);
            const xm = x1 + (dx * a) / d;
            const ym = y1 + (dy * a) / d;
            const xs1 = xm + (h * dy) / d;
            const ys1 = ym - (h * dx) / d;
            const xs2 = xm - (h * dy) / d;
            const ys2 = ym + (h * dx) / d;
            // if (ys1 > ys2 || (ys1 === ys2 && xs1 > xs2)) {
            if (ys1 + xs1 > ys2 + xs2) {  
                return { x: xs1, y: ys1 };
            } else {
                return { x: xs2, y: ys2 };
            }
        }
        
        function tangentAngle(intersection, circle1, circle2) {
            // Convert points to vectors
            const u = { x: circle1.x - intersection.x, y: circle1.y - intersection.y };
            const v = { x: circle2.x - intersection.x, y: circle2.y - intersection.y };
            // Dot product of u and v
            const dotProduct = u.x * v.x + u.y * v.y;
            // Magnitudes of u and v
            const magnitudeU = Math.sqrt(u.x * u.x + u.y * u.y);
            const magnitudeV = Math.sqrt(v.x * v.x + v.y * v.y);
            // Cosine of the angle between u and v
            const cosTheta = dotProduct / (magnitudeU * magnitudeV);
            // Angle in radians
            const theta = Math.acos(cosTheta);
            // Intersection angle (angle between tangents)
            return intersectionAngle = theta;
        }

        // const scale = {f:4, xo: -100, yo: -100} 
        function rescale(o_in) {
          const o = {...o_in}
          o.x = (o.x + scale.xo) * scale.f;
          o.y = (o.y + scale.yo) * scale.f;
          ['start', 'end'].forEach((v) => {
            if (o[v]) {
              o[v] = rescale(o[v])
            }
          });
          ['radius', 'height', 'thickness', 'lineWidth', 'fontsize', 'offset'].forEach((v) => {
            if (o[v]) {
              o[v] = o[v] * scale.f
            }
          });
          return o
        }

        function label(p) {
            const {x, y, text, alignment, fontsize, color, offset}
                = rescale({alignment: 'left', fontsize: 4, color: 'darkgrey', offset: 15 , ...p});
            ctx.font = `${fontsize}px Arial`;
            ctx.fillStyle = color;
            let textX = x, textY = y;
            switch (alignment) {
                case 'right':
                    textX += offset;
                    textY += fontsize / 2;
                    break;
                case 'above':
                    textX -= ctx.measureText(text).width / 2;
                    textY -= offset;
                    break;
                case 'below':
                    textX -= ctx.measureText(text).width / 2;
                    textY += offset + fontsize;
                    break;
                default: // 'left'
                    textX -= offset + ctx.measureText(text).width;
                    textY += fontsize / 2;
                    break;
            }
            ctx.fillText(text, textX, textY);
        }
        
        function drawDot(params) {
          const p = rescale({style: 'blue', radius: 2, ...params})
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
          ctx.fillStyle = p.style; // Set the fill color to blue
          ctx.fill();
        }

        function drawGlottis(params) {
          const p = rescale({lineWidth: 4, ...params})
          // Create a linear gradient for the glottis line
          const gradient = ctx.createLinearGradient(p.start.x, p.start.y, p.end.x, p.end.y);
          gradient.addColorStop(0, '#ff8888'); // Light pink color at the start
          gradient.addColorStop(1, '#ff3333'); // Darker pink color at the end
          ctx.beginPath();
          ctx.moveTo(p.start.x, p.start.y);
          ctx.lineTo(p.end.x, p.end.y);
          ctx.strokeStyle = gradient; // Set the stroke color to the gradient
          ctx.lineWidth = p.lineWidth 
          ctx.stroke();
        }

        function drawTooth(params) {
          const p = rescale({lineWidth: 2, ...params});
          const width = p.height/3;
          const gradient = ctx.createLinearGradient(p.x, p.y, p.x + p.height, p.y);
          gradient.addColorStop(0, '#fff'); // White color at the start
          gradient.addColorStop(0.5, '#ddd'); // Light grey in the middle
          gradient.addColorStop(1, '#fff'); // White color at the end

          ctx.fillStyle = gradient; // Set the fill color to the gradient
          ctx.strokeStyle = 'grey'; // Set the color 
          ctx.beginPath();
          ctx.moveTo(p.x,p.y);
          ctx.lineTo(p.x+p.height, p.y+width);
          ctx.lineTo(p.x+p.height, p.y-width);
          ctx.closePath();
          ctx.fill();
          ctx.lineWidth = p.lineWidth // Set the line width for the triangle 
          ctx.stroke();
        }
  
        function drawArc(params) {
            const p = rescale({style: 'blue', radius: 5, thickness:4, ...params})
            if (p.style === 'tube') {
              p.style = ctx.createRadialGradient(p.x, p.y, p.radius - p.thickness, p.x, p.y, p.radius + p.thickness);
              p.style.addColorStop(0, 'rgba(255, 255, 255, 0.5)'); // Inner color (transparent white)
              p.style.addColorStop(1, 'rgba(0, 0, 255, 0.5)'); // Outer color (transparent blue)
            } else if (p.style === 'metal') {
                p.style = ctx.createRadialGradient(p.x, p.y, p.radius - p.thickness, p.x, p.y, p.radius + p.thickness);
                p.style.addColorStop(0, 'rgba(192, 192, 192, 0.5)'); // Inner color (light grey)
                p.style.addColorStop(1, 'rgba(128, 128, 128, 0.5)'); // Outer color (darker grey)
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, p.startAngle, p.endAngle);
            ctx.lineWidth = p.thickness;
            ctx.strokeStyle = p.style; // Set the color for the bounding box
            ctx.stroke();
        }

      function updateValues() {
          sliders.forEach(slider => {
              e(`${slider}Value`).textContent = e(slider).value;
          });
      }

      init();

    </script>
</body>
</html>
      
