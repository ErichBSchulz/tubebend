<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracheal Intubation Geometry Simulation</title>
    <style>
  .description {
      font-size: 0.8em;
      color: #666;
      display: block; /* Ensure description is on a new line */
      margin-top: 5px; /* Add some space above the description */
  }
  .slider-container {
      margin: 10px 0;
      display: flex;
      flex-direction: column; /* Stack elements vertically */
  }
  .slider-row {
      display: flex;
      align-items: center;
  }
  .slider-container label {
      width: 200px; /* Adjust width as needed */
      text-align: right;
      margin-right: 10px;
  }
  .slider-container input[type="range"] {
      flex: 1;
      margin: 0 10px;
  }
  .slider-container span {
      width: 50px; /* Adjust width as needed */
      text-align: left;
  }
  html, body {
      height: 100%;
      margin: 0;
      padding: 0;
  }
  .container {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      height: 100%;
  }
  .left-column {
      flex: 2;
      padding: 10px;
      background-color: #f0f0f0;
      height: 100%;
  }
  .right-column {
      flex: 1;
      min-width: 300px;
      padding: 10px;
      background-color: #f0f0f0;
      height: 100%;
  }
  .canvas-wrapper {
      position: relative;
      width: 100%;
      padding-bottom: 100%; /* 1:1 aspect ratio */
      height: 0;
  }
  #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
  }
</style>
  
</head>
<body>
    <h1>Tracheal Intubation Geometry Simulation in 2D</h1>

    <div class="container">
        <div class="left-column">
            <div class="canvas-wrapper">
                <canvas id="canvas" width="400" height="400"></canvas>
            </div>
        </div>
        <div class="right-column">
    <h2>Parameters</h2>
    <div class="slider-container">
<div class="slider-row">
        <label for="tubeAngle">Tube Angle (degrees): </label>
        <input type="range" id="tubeAngle" min="170" max="250" value="206">
        <span id="tubeAngleValue">0</span>
</div>
        <p class="description">This is the angle the tube leaves the upper incisors.</p>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="incisorBend">Incisor Bend (degrees): </label>
        <input type="range" id="incisorBend" min="0" max="180" value="20">
        <span id="incisorBendValue">0</span>
</div>
        <p class="description">Bending is a result of the tube being bent over the upper incisors.</p>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="glotticPlaneX">Glottic Plane X (mm):</label>
        <input type="range" id="glotticPlaneX" min="90" max="300" value="165">
        <span id="glotticPlaneXValue">0</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="tubeLength">Tube Length (mm): </label>
        <input type="range" id="tubeLength" min="90" max="300" value="280">
        <span id="tubeLengthValue">0</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="tubeRadius">Tube Radius (mm): </label>
        <input type="range" id="tubeRadius" min="50" max="500" value="150">
        <span id="tubeRadiusValue">0</span>
</div>
        <p class="description">The radius of curvature of standard tracheal tube is 140mm when it leaves the packet,
            but bending over the teeth will increase this.</p>
    </div>
    <h2>Laryngoscope Blade</h2>
    <div class="slider-container">
<div class="slider-row">
        <label for="bladeLength">Blade Length (mm): </label>
        <input type="range" id="bladeLength" min="40" max="150" value="140">
        <span id="bladeLengthValue">0</span>
</div>
        <p class="description">Macintosh blade #3 and #4 are 101mm and 135mm long respectively.</p>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="bladeInsertion">Blade Insertion (%): </label>
        <input type="range" id="bladeInsertion" min="50" max="100" value="72">
        <span id="bladeInsertionValue">0</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="bladeRadius">Blade Curvature Radius (mm): </label>
        <input type="range" id="bladeRadius" min="70" max="140" value="118">
        <span id="bladeRadiusValue">0</span>
</div>
        <p class="description">Macintosh blade #3 and #4 have radii of 118mm and 136mm respectively.</p>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="bladeAngle">Blade angle (degrees): </label>
        <input type="range" id="bladeAngle" min="-20" max="70" value="18">
        <span id="bladeAngleValue">0</span>
</div>
        <p class="description">This is the angle at the incisors.</p>
    </div>
    <h2>Dentition</h2>
    <div class="slider-container">
<div class="slider-row">
        <label for="lowerIncisorX">Lower Incisor X (mm): </label>
        <input type="range" id="lowerIncisorX" min="-100" max="10" value="-25">
        <span id="lowerIncisorXValue">0</span>
</div>
        <p class="description">Mouth opening as measured horizontally.</p>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="lowerIncisorY">Lower Incisor Y (mm): </label>
        <input type="range" id="lowerIncisorY" min="-50" max="50" value="0">
        <span id="lowerIncisorYValue">0</span>
</div>
        <p class="description">Under or overbite.</p>
    </div>
    <h2>Reference params</h2>
<!-- 
    <div class="slider-container">
<div class="slider-row">
        <label for="qqq">qqq (degrees): </label>
        <input type="range" id="qqq" min="0" max="360" value="0">
        <span id="qqqValue">0</span>
</div>
    </div>
    -->

    <p class="description">This moves a small pink fiducial.</p>
    <div class="slider-container">
<div class="slider-row">
        <label for="startAngle">Start Angle (degrees): </label>
        <input type="range" id="startAngle" min="0" max="360" value="0">
        <span id="startAngleValue">0</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="endAngle">End Angle (degrees): </label>
        <input type="range" id="endAngle" min="0" max="360" value="360">
        <span id="endAngleValue">90</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="thickness">Thickness: </label>
        <input type="range" id="thickness" min="1" max="20" value="1">
        <span id="thicknessValue">5</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="x">X Coordinate: </label>
        <input type="range" id="x" min="0" max="400" value="0">
        <span id="xValue">250</span>
</div>
    </div>
    <div class="slider-container">
<div class="slider-row">
        <label for="y">Y Coordinate: </label>
        <input type="range" id="y" min="0" max="400" value="0">
        <span id="yValue">250</span>
</div>
    </div>
        </div>
    </div>

    <h1>Notes:</h1>
    <p>This page aims to help those seeking to learn or teach tracheal intubation understand the geometry.</p>
    <p>Above is a simplified diagram showing the upper and lower incisors (white triangles), the laryngoscope blade (grey arc) and a tracheal tube. A blue bar is placed a the level of the blade tip to provide a approximate reference for the glottic opening between the vocal cords.</p>
    <p>Tracheal intubation is a vital skill for paramedics and emergency doctors, but training opportunities are scarce.
      The challenges in gaining experience
      requires innovative training methods to maximimise the chances healthcare workers can intubate in emergency situations. 
    </p>
    <p>This page illustrates the adverse impact of bending an endotracheal tube over the upper incisors while attempting tracheal intubation.</p>
    <ul>
        <li>The adverse impact of bending over the incisors are exaggerated by a small blade radius and increased tube radius. Bending the tube over the teeth leads to a vicious cycle as the tube radius increases (i.e. the tube gets straighter) as the tube is bent over the teeth.</li>
        <li>This simulation divides the tube into three sections as it bends between the upper incisors and the laryngoscope blade. Section 1 is outside the mouth. Section 2 is between the incisors and the blade. Section 3 is the section that is deflected tangentially off the blade.</li>
        <li>Giving the tube a tighter radius than the blade breaks the simulation.</li>
    </ul>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const sliders = [ 'tubeAngle', 'incisorBend', 'tubeRadius', 'glotticPlaneX', 'tubeLength',
          'bladeLength', 'bladeInsertion', 'bladeRadius', 'bladeAngle', 'lowerIncisorX', 'lowerIncisorY', 
          'startAngle', 'endAngle', 'thickness', 'x', 'y']
        // shortcut function
        const e = document.getElementById.bind(document);
        // shortcut to read value
        const ev = id => +e(id).value;
        // read degrees and convirt to radians
        const toRadians = degrees => (degrees * Math.PI) / 180;
        const toDegrees = radians => (radians / Math.PI) * 180;
        const evd = id => toRadians(ev(id));

        function init() {
          sliders.forEach(slider => e(slider).addEventListener('input', redraw));
          redraw()
        }

        function redraw() {
          updateValues();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const toothX= 300;
          const toothY= 200;
          const lowerIncisorX = toothX + ev('lowerIncisorX')
          const lowerIncisorY = toothY + ev('lowerIncisorY')
          // draw teeth
          drawTooth({x: toothX,y: toothY, height:15});
          drawTooth({x: lowerIncisorX, y: lowerIncisorY, height:-15});


          // draw blade
          const bladeLength = ev('bladeLength')
          console.log('bladeLength', bladeLength)
          const bladeInsertion = ev('bladeInsertion')
          console.log('bladeInsertion', bladeInsertion)
          const bladeRadius = ev('bladeRadius')
          console.log('bladeRadius', bladeRadius)
          const bit = bladeLength/(bladeRadius*2)
          // const bit = bladeRadius/(bladeLength/2)
          console.log('bit', bit)
          const bladeRadians = Math.asin(bit) * 2;
          console.log('bladeRadians', bladeRadians)
          const bladeAngle = evd('bladeAngle')
          const bladeCentre = translate({x: lowerIncisorX, y: lowerIncisorY, angle: bladeAngle + Math.PI, distance: bladeRadius});
          // drawDot({...bladeCentre, style: 'yellow'});
          const blade = { ...bladeCentre, 
            startAngle: bladeAngle-bladeRadians*(1- (bladeInsertion/100)),
            endAngle: bladeAngle + bladeRadians*((bladeInsertion/100)),
            radius: bladeRadius, 
            thickness: 3,
            style: "grey"}
            console.log('blade', blade)
            console.log('blade angle', blade.startAngle-blade.endAngle)
          const bladeTip = translate({...bladeCentre, angle: blade.endAngle, distance: blade.radius })

          drawArc(blade);
          drawDot(bladeTip);

          const tubeLength = ev('tubeLength')
          const tubeRadius = ev('tubeRadius')

          const tubeArcAngle = tubeLength / tubeRadius 
          // const circ = tubeRadius * 2 * Math.PI;
          // const fraction = tubeLength / circ; 
          const tubeRadians = tubeLength / tubeRadius;
          const tubeAngle = evd('tubeAngle');
          const incisorBend = evd('incisorBend');
          const tubeParams = {style: "tube", radius: tubeRadius, thickness: 10};

          const glotticPlaneX = ev('glotticPlaneX')
          drawLine({start: {x: glotticPlaneX, y: bladeTip.y-10}, end: {x: glotticPlaneX, y: bladeTip.y+10}, })

          // place three reference dots for tube bending
          const inflection = translate({x: toothX-tubeParams.thickness/2, y: toothY, angle: tubeAngle, distance: tubeRadius})
          // drawDot(inflection);
          const outerCentre = translate({x: toothX-tubeParams.thickness/2, y: toothY, angle: tubeAngle + incisorBend/2, distance: tubeRadius})
          // drawDot(outerCentre);
          const innerCentre = inflection; 
          // drawDot({...innerCentre, style: 'red'});
        
          // draw first arc
          const angleToTooth1 = tubeAngle + incisorBend/2 + Math.PI; 
          const arcParams1 = { ...outerCentre, endAngle: angleToTooth1, startAngle: angleToTooth1 - 1, ...tubeParams};
          // draw second arc
          const angleToTooth2 = tubeAngle + Math.PI; 
          const arcParams2 = { ...innerCentre, startAngle: angleToTooth2, endAngle: angleToTooth2 + 1, ...tubeParams};
          var drawnTubeRadians = 0;
          // find the intersection of the tube and blade
          const intersection = findIntersection(arcParams2, 
            // modify blade to add thicness
            {...blade, radius: blade.radius + (blade.thickness+tubeParams.thickness)/2});
          if (intersection !== null && intersection.x > bladeTip.x && intersection.y > toothY) { 
              // calculate bearing from centre of blade curve to intersection point so can 
              // calucate the new rotation centre of a tangental tube
              const tubeBladeAxisBearing = calculateBearing(intersection, blade);
              // get the anglar location of the tube so we can derive the length of the section 3
              const tube2AxisBearing = calculateBearing(intersection, arcParams2);
              arcParams2.endAngle = tube2AxisBearing.angle - Math.PI;
              // todo draw the "ghost" tube
            const arc3Centre = translate({...intersection, angle: tubeBladeAxisBearing.angle,
              distance: tubeRadius});
            const arcParams3 = {...arc3Centre, ...tubeParams}
              // drawDot(arc3Centre)
              const tangentBearing = tubeBladeAxisBearing.angle + Math.PI;
              arcParams3.startAngle = tangentBearing;
              // arcParams3.radius = tubeRadius;
              // arcParams3.style = 'tube';

              // calculate angle to glotticPlaneX
              const deltaX = glotticPlaneX - arcParams3.x;
              //const finalAngle = Math.asin(deltaX/arcParams3.radius);
              const finalAngle = Math.acos(deltaX/arcParams3.radius);
              arcParams3.endAngle = finalAngle > arcParams3.startAngle ? finalAngle : arcParams3.startAngle;
              drawArc(arcParams3);
              drawnTubeRadians += arcRadians(arcParams3);
              drawDot({...intersection, style: 'red'});
          }
          else {
            // no collision
            // arcParams2.style = "green"
            // calculate angle to glotticPlaneX
            const deltaX = glotticPlaneX - arcParams2.x;
            //const finalAngle = Math.asin(deltaX/arcParams2.radius);
            const finalAngle = Math.acos(deltaX/arcParams2.radius);
            arcParams2.endAngle = finalAngle;
          }
          drawArc(arcParams2);
          // figure out how much tube has been drawn so far:
          drawnTubeRadians += arcRadians(arcParams2);
          const remainingRadians = tubeRadians - drawnTubeRadians;
          if (remainingRadians > 0) {
            arcParams1.startAngle = arcParams1.endAngle - remainingRadians;
            drawArc(arcParams1);
          }

          // reference arc 
          const startAngle = evd("startAngle");
          const endAngle = evd("endAngle");
          const thickness = ev("thickness");
          const x = ev("x");
          const y = ev("y");
          const radius = 5;
          const style = "pink";
          const arcParams = { startAngle, endAngle, thickness, x, y, radius, style };
          drawArc(arcParams);
        }

        // cartesian translation
        function arcRadians(arc) {
          var r = (arc.endAngle - arc.startAngle) % (2 * Math.PI);
          if (r<0) {
            r+=2 * Math.PI;
          }
          return r;
        }

        // cartesian translation
        function translate({x, y, angle, distance}) {
          return {x: x+Math.cos(angle)*distance, y: y+Math.sin(angle)*distance, }
        }

        // given two points calcuate angle and distance between them
        function calculateBearing(point1, point2) {
            const { x: x1, y: y1 } = point1;
            const { x: x2, y: y2 } = point2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            // calculate distance between points
            const distance = Math.sqrt(dx * dx + dy * dy);
            return {angle, distance};
        }

        // get the cordinates of the tip of an arc
        function arcTip(params) {
          return translate({...params, angle: params.endAngle})
        }

        // Calculate the intersection of two circles and 
        // returns the one with the highest Y value (and highest X value if there's a tie).
        function findIntersection(circle1, circle2) {
            const { x: x1, y: y1, radius: r1 } = circle1;
            const { x: x2, y: y2, radius: r2 } = circle2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d > r1 + r2 || d < Math.abs(r1 - r2)) {
                // No intersection
                return null;
            }
            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h = Math.sqrt(r1 * r1 - a * a);
            const xm = x1 + (dx * a) / d;
            const ym = y1 + (dy * a) / d;
            const xs1 = xm + (h * dy) / d;
            const ys1 = ym - (h * dx) / d;
            const xs2 = xm - (h * dy) / d;
            const ys2 = ym + (h * dx) / d;
            // if (ys1 > ys2 || (ys1 === ys2 && xs1 > xs2)) {
            if (ys1 + xs1 > ys2 + xs2) {  
                return { x: xs1, y: ys1 };
            } else {
                return { x: xs2, y: ys2 };
            }
        }

        function drawDot(params) {
          const p = {style: 'blue', radius: 2, ...params}
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
          ctx.fillStyle = p.style; // Set the fill color to blue
          ctx.fill();
        }

        function drawLine(params) {
          const p = {style: 'blue', ...params}
          ctx.beginPath();
          ctx.moveTo(p.start.x, p.start.y)
          ctx.lineTo(p.end.x, p.end.y)
          ctx.strokeStyle = p.style; 
          ctx.stroke();
        }

        function drawTooth({ x, y, height}) {
          const width = height/2;
          ctx.fillStyle = 'white'; // Set the fill color to blue
          ctx.strokeStyle = 'grey'; // Set the color 
          ctx.beginPath();
          ctx.moveTo(x,y);
          ctx.lineTo(x+height, y+width);
          ctx.lineTo(x+height, y-width);
          ctx.closePath();
          ctx.fill();
          ctx.lineWidth = 2; // Set the line width for the triangle 
          ctx.stroke();
        }
  
        function drawArc(params) {
            const p = {style: 'blue', radius: 5, thickness:4, ...params}
            if (p.style === 'tube') {
              p.style = ctx.createRadialGradient(p.x, p.y, p.radius - p.thickness, p.x, p.y, p.radius + p.thickness);
              p.style.addColorStop(0, 'rgba(255, 255, 255, 0.5)'); // Inner color (transparent white)
              p.style.addColorStop(1, 'rgba(0, 0, 255, 0.5)'); // Outer color (transparent blue)
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, p.startAngle, p.endAngle);
            ctx.lineWidth = p.thickness;
            ctx.strokeStyle = p.style; // Set the color for the bounding box
            ctx.stroke();
        }

      function updateValues() {
          sliders.forEach(slider => {
              e(`${slider}Value`).textContent = e(slider).value;
          });
      }

      init();

    </script>
</body>
</html>
      
